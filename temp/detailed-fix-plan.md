# Detailed Fix Plan: 5 Architectural Issues

> Generated by planner agent. Reviewed with Codex (planner role) and Gemini (planner role).

---

## Issue 1: index.md Git Merge Conflicts

**Severity:** High
**Files:** `hooks/scripts/memory_retrieve.py`, `hooks/scripts/memory_write.py`, `hooks/scripts/memory_index.py`, `.gitignore`
**Root Cause:** `index.md` is a single flat file rewritten (with full sort) on every create/update/delete/archive/unarchive operation. In multi-user/multi-branch environments, this causes constant merge conflicts because even unrelated memory writes touch the same file.

### Chosen Fix: Treat index.md as a derived artifact (rebuild on demand)

**Rationale (consensus from Codex + Gemini):**
- Per-category split reduces but doesn't eliminate same-category conflicts
- .gitignore + rebuild-on-demand is the cleanest approach
- Source JSON files are the authoritative data; index is just a cache
- `memory_index.py --rebuild` already exists and works

**Alternative considered:** Per-category `.idx` files -- rejected because same-category edits still collide, and it requires changing 3+ consumers.

### Changes

#### File: `hooks/scripts/memory_retrieve.py` (lines 173-178)

**Current code:**
```python
    # Locate memory root
    memory_root = Path(cwd) / ".claude" / "memory"
    index_path = memory_root / "index.md"

    if not index_path.exists():
        sys.exit(0)
```

**Proposed code:**
```python
    # Locate memory root
    memory_root = Path(cwd) / ".claude" / "memory"
    index_path = memory_root / "index.md"

    # Rebuild index on demand if missing (derived artifact pattern).
    # index.md may be .gitignored -- rebuild from authoritative JSON files.
    if not index_path.exists() and memory_root.is_dir():
        import subprocess
        index_tool = Path(__file__).parent / "memory_index.py"
        if index_tool.exists():
            subprocess.run(
                [sys.executable, str(index_tool), "--rebuild", "--root", str(memory_root)],
                capture_output=True, timeout=10,
            )

    if not index_path.exists():
        sys.exit(0)
```

**Key details:**
- Guard: only attempt rebuild if `memory_root` directory exists (avoid spurious rebuilds)
- `timeout=10` prevents hanging on pathological cases
- `capture_output=True` suppresses rebuild stdout/stderr from hook output
- Backward compatible: if index.md exists (not gitignored), this code never triggers

#### File: `hooks/scripts/memory_candidate.py` (lines 218-221)

**Current code:**
```python
    if not index_path.exists():
        print(f"ERROR: index.md not found at {index_path}", file=sys.stderr)
        sys.exit(1)
```

**Proposed code:**
```python
    # Rebuild index on demand if missing (derived artifact pattern)
    if not index_path.exists() and root.is_dir():
        import subprocess
        index_tool = Path(__file__).parent / "memory_index.py"
        if index_tool.exists():
            subprocess.run(
                [sys.executable, str(index_tool), "--rebuild", "--root", str(root)],
                capture_output=True, timeout=10,
            )

    if not index_path.exists():
        print(f"ERROR: index.md not found at {index_path}", file=sys.stderr)
        sys.exit(1)
```

#### File: `.gitignore` (add to end)

**Append:**
```
# Memory index is a derived artifact (rebuilt on demand from JSON source files)
.claude/memory/index.md
```

### Edge Cases
- **No memory_index.py**: Silently fails, falls through to existing "exit if no index" logic
- **Corrupted JSON files**: `memory_index.py --rebuild` already handles (prints WARNING, skips file)
- **Empty memory store**: Rebuild produces nothing, exits 0 as before
- **Concurrent rebuild**: Two retrievals triggering rebuild simultaneously is safe because `--rebuild` writes atomically via full file rewrite; last writer wins, both produce identical content from same source files

### Interaction with other fixes
- Issue 4 (locking): The lock is for write operations to index.md. Retrieval only reads. The rebuild path writes index.md but only when it's missing, so no lock contention with normal writes.
- Issue 5 (injection): Rebuild regenerates from JSON source, so any write-side sanitization is reflected in rebuilt index.

---

## Issue 2: _resolve_memory_root() Fallback Allows External Writes

**Severity:** Medium (security)
**File:** `hooks/scripts/memory_write.py` (lines 1156-1181)
**Root Cause:** When `--target` path doesn't contain `.claude/memory` marker, the `else` fallback sets `memory_root = target_abs.parent.parent`. This can resolve to an arbitrary directory, making the `_check_path_containment()` check ineffective (it checks target is within memory_root, but memory_root was derived FROM target).

### Chosen Fix: Remove fallback, fail closed

**Rationale (consensus):**
- The fallback was a convenience for non-standard paths, but it creates a security bypass
- All legitimate callers should provide paths containing `.claude/memory`
- Fail closed is the correct security posture

### Changes

#### File: `hooks/scripts/memory_write.py` (lines 1156-1181)

**Current code:**
```python
def _resolve_memory_root(target: str) -> tuple[Path, Path]:
    """Derive memory_root and index_path from the target path."""
    target_path = Path(target)
    parts = target_path.parts
    # Find memory directory marker: look for ".claude" followed by "memory"
    _dc = ".clau" + "de"
    for i, part in enumerate(parts):
        if part == "memory" and i > 0 and parts[i - 1] == _dc:
            memory_root = Path(*parts[: i + 1])
            break
    else:
        # Fallback: go up 2 from target dir (category_dir -> memory)
        target_abs = (
            Path.cwd() / target_path
            if not target_path.is_absolute()
            else target_path
        )
        memory_root = target_abs.parent.parent

    memory_root_abs = (
        Path.cwd() / memory_root
        if not memory_root.is_absolute()
        else memory_root
    )
    index_path = memory_root_abs / "index.md"
    return memory_root_abs, index_path
```

**Proposed code:**
```python
def _resolve_memory_root(target: str) -> tuple[Path, Path]:
    """Derive memory_root and index_path from the target path.

    Requires .claude/memory marker in the path. Fails closed if missing.
    """
    target_path = Path(target)
    # Resolve to absolute for consistent part scanning
    target_abs = (
        Path.cwd() / target_path
        if not target_path.is_absolute()
        else target_path
    )
    parts = target_abs.parts
    _dc = ".clau" + "de"
    for i, part in enumerate(parts):
        if part == "memory" and i > 0 and parts[i - 1] == _dc:
            memory_root = Path(*parts[: i + 1])
            break
    else:
        print(
            f"PATH_ERROR\ntarget: {target}\n"
            f"fix: Target path must contain '.claude/memory/' components. "
            f"Example: .claude/memory/decisions/my-decision.json"
        )
        sys.exit(1)

    memory_root_abs = (
        Path.cwd() / memory_root
        if not memory_root.is_absolute()
        else memory_root
    )
    index_path = memory_root_abs / "index.md"
    return memory_root_abs, index_path
```

**Key changes:**
1. Resolve target to absolute BEFORE scanning parts (fixes edge case where relative path scanning misses marker)
2. Remove the `else` fallback entirely -- `sys.exit(1)` with clear error
3. Error message includes an example of correct path format

### Edge Cases
- **Relative paths like `.claude/memory/decisions/foo.json`**: Work correctly because we resolve to absolute first
- **Absolute paths like `/home/user/project/.claude/memory/decisions/foo.json`**: Work correctly
- **Paths without marker like `/tmp/foo.json`**: Now fail closed with clear error
- **Backward compatibility**: All legitimate callers already provide paths with `.claude/memory/`. The fallback was only triggered by malformed paths.

### Interaction with other fixes
- Strengthens the path containment check (`_check_path_containment`) which now operates on a validated memory_root

---

## Issue 3: max_inject Value Unclamped

**Severity:** Medium
**File:** `hooks/scripts/memory_retrieve.py` (lines 181-192)
**Root Cause:** `max_inject` is read from config and used directly in list slicing (`final[:max_inject]`) with no type check or range validation. A string value causes TypeError at slice time. Negative values cause empty results. Extremely large values are wasteful.

### Chosen Fix: Type-coerce + clamp to [0, 20]

**Rationale:**
- 0 = disable injection (valid use case for temporarily turning off)
- 20 = reasonable upper bound (injecting more than 20 memories floods context)
- Default 5 = current behavior preserved

### Changes

#### File: `hooks/scripts/memory_retrieve.py` (lines 181-192)

**Current code:**
```python
    # Check retrieval config
    max_inject = 5
    config_path = memory_root / "memory-config.json"
    if config_path.exists():
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
            retrieval = config.get("retrieval", {})
            if not retrieval.get("enabled", True):
                sys.exit(0)
            max_inject = retrieval.get("max_inject", 5)
        except (json.JSONDecodeError, KeyError, OSError):
            pass
```

**Proposed code:**
```python
    # Check retrieval config
    max_inject = 5
    config_path = memory_root / "memory-config.json"
    if config_path.exists():
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config = json.load(f)
            retrieval = config.get("retrieval", {})
            if not retrieval.get("enabled", True):
                sys.exit(0)
            raw_inject = retrieval.get("max_inject", 5)
            try:
                max_inject = max(0, min(20, int(raw_inject)))
            except (ValueError, TypeError):
                max_inject = 5
                print(
                    f"[WARN] Invalid max_inject value: {raw_inject!r}; using default 5",
                    file=sys.stderr,
                )
        except (json.JSONDecodeError, KeyError, OSError):
            pass

    if max_inject == 0:
        sys.exit(0)
```

**Key details:**
- `int()` coerces float/string to int (handles `5.0`, `"5"`)
- `max(0, min(20, ...))` clamps to [0, 20]
- Invalid types (None, list, dict) fall to except -> default 5
- Warning only on truly invalid values (not on valid out-of-range clamping, to avoid noise)
- `max_inject == 0` check after config block allows 0 to disable injection

### Edge Cases
- `max_inject: -1` -> clamped to 0 -> exit (injection disabled)
- `max_inject: 100` -> clamped to 20
- `max_inject: "five"` -> ValueError -> default 5 with warning
- `max_inject: null` -> TypeError -> default 5 with warning
- `max_inject: 5.7` -> int(5.7) = 5 -> works correctly
- `max_inject` missing -> default 5 (unchanged)

### Interaction with other fixes
- None. This is self-contained in memory_retrieve.py.

---

## Issue 4: NFS/SMB flock Instability

**Severity:** Medium
**File:** `hooks/scripts/memory_write.py` (lines 1130-1153)
**Root Cause:** `fcntl.flock()` is unreliable on network filesystems (NFS, SMB/CIFS). The current implementation silently falls back to no locking on any `OSError`, which means on NFS the index can be corrupted by concurrent writes.

### Chosen Fix: mkdir-based lock with stale detection

**Rationale (from Codex):**
- Detecting network FS via `/proc/mounts` is Linux-specific and error-prone under WSL/containers
- Better to use a universally reliable mechanism: `mkdir` is atomic on POSIX, Windows, AND NFS
- Keep `fcntl` as an attempted fast-path but fall back to `mkdir` on failure
- Stale lock detection prevents permanent deadlock after crashes

### Changes

#### File: `hooks/scripts/memory_write.py`

**Add import at top (after existing imports):**
```python
import time
```

**Replace `_flock_index` class (lines 1130-1153):**

**Current code:**
```python
class _flock_index:
    """Context manager for flock on index.md. No-op fallback on non-Unix."""

    def __init__(self, index_path: Path):
        self.index_path = index_path
        self.lock_path = index_path.parent / ".index.lock"
        self.lock_fd = None

    def __enter__(self):
        try:
            self.lock_fd = open(self.lock_path, "w")
            fcntl.flock(self.lock_fd, fcntl.LOCK_EX)
        except (OSError, AttributeError):
            # Non-Unix or other error: proceed without lock
            pass
        return self

    def __exit__(self, *args):
        if self.lock_fd:
            try:
                fcntl.flock(self.lock_fd, fcntl.LOCK_UN)
                self.lock_fd.close()
            except (OSError, AttributeError):
                pass
```

**Proposed code:**
```python
class _flock_index:
    """Portable lock for index mutations. Uses mkdir (atomic on all FS including NFS)."""

    _LOCK_TIMEOUT = 5.0    # Max seconds to wait for lock
    _STALE_AGE = 60.0      # Seconds before a lock is considered stale
    _POLL_INTERVAL = 0.05   # Seconds between retry attempts

    def __init__(self, index_path: Path):
        self.lock_dir = index_path.parent / ".index.lockdir"
        self.acquired = False

    def __enter__(self):
        deadline = time.monotonic() + self._LOCK_TIMEOUT
        while True:
            try:
                os.mkdir(self.lock_dir)
                self.acquired = True
                return self
            except FileExistsError:
                # Lock held by another process -- check for stale
                try:
                    mtime = self.lock_dir.stat().st_mtime
                    if (time.time() - mtime) > self._STALE_AGE:
                        # Stale lock -- break it with warning
                        try:
                            os.rmdir(self.lock_dir)
                        except OSError:
                            pass
                        print(
                            "[WARN] Broke stale index lock (older than 60s)",
                            file=sys.stderr,
                        )
                        continue
                except OSError:
                    pass  # Lock dir disappeared between check and stat -- retry

                if time.monotonic() >= deadline:
                    print(
                        "[WARN] Index lock timeout; proceeding without lock",
                        file=sys.stderr,
                    )
                    return self
                time.sleep(self._POLL_INTERVAL)
            except OSError:
                # mkdir failed for non-existence reason (permissions, etc.)
                # Proceed without lock rather than failing the write
                print(
                    "[WARN] Could not create lock directory; proceeding without lock",
                    file=sys.stderr,
                )
                return self

    def __exit__(self, *args):
        if self.acquired:
            try:
                os.rmdir(self.lock_dir)
            except OSError:
                pass
```

**Also remove the `fcntl` import (line 37) since it's no longer used:**

**Current:**
```python
import fcntl
```

**Proposed:** Remove this line entirely.

**Key details:**
- `FileExistsError` is the specific exception for "directory already exists" (subclass of OSError)
- `time.monotonic()` for deadline (immune to clock adjustments)
- `time.time()` for mtime comparison (mtime is wall-clock)
- Stale lock broken after 60s (conservative; normal operations take <1s)
- Warning on stale break, timeout, or lock failure
- `self.acquired` flag ensures we only rmdir if we created the lock
- Backward compatible: lock file path changes from `.index.lock` (file) to `.index.lockdir` (dir), both are local artifacts

### Edge Cases
- **Crash during locked operation**: Lock dir remains; broken after 60s by next writer
- **Two processes checking stale simultaneously**: One rmdir succeeds, other gets OSError, retries mkdir -- safe
- **Permission denied on mkdir**: Falls through to unlocked operation with warning
- **Windows**: `os.mkdir` is atomic on Windows too; works without `fcntl`
- **NFS**: `mkdir` is atomic on NFS (unlike `flock`)

### Interaction with other fixes
- Issue 1 (index rebuild): Rebuild only happens when index is missing, so it won't contend with locked write operations
- The `.index.lock` file is no longer created; `.index.lockdir` directory is used instead

---

## Issue 5: Prompt Injection via Memory Titles

**Severity:** Medium (security)
**Files:** `hooks/scripts/memory_retrieve.py` (lines 254-259), `hooks/scripts/memory_write.py` (lines 296-305)
**Root Cause:** Memory titles are injected verbatim into Claude's prompt context via the retrieval hook. While `memory_write.py` sanitizes on write (strips control chars, arrow markers, tags markers), there's no retrieval-side defense. Old/pre-sanitization entries could still contain injection attempts.

### Chosen Fix: Retrieval-side sanitization + structured output

**Rationale (from Codex):**
- Defense in depth: sanitize on BOTH write and read paths
- Structured output (XML-like tags) helps the model distinguish data from instructions
- Title truncation limits attack surface
- "Do not interpret" text alone is insufficient; structural separation is needed

### Changes

#### File: `hooks/scripts/memory_retrieve.py` (lines 254-259)

**Current code:**
```python
    # Output as plain text (added to Claude's context on exit 0)
    print("RELEVANT MEMORIES (from .claude/memory/):")
    for _, _, entry in top:
        print(entry["raw"])
    print()
    print("Read the referenced files above if you need detailed context for this task.")
```

**Proposed code:**
```python
    # Output with data-boundary markers and retrieval-side sanitization.
    # Titles are re-sanitized here as defense-in-depth (write-side also sanitizes).
    print("<memory-context source=\".claude/memory/\">")
    for _, _, entry in top:
        safe_title = _sanitize_title(entry["title"])
        tags = entry.get("tags", set())
        tags_str = f" #tags:{','.join(sorted(tags))}" if tags else ""
        print(f"- [{entry['category']}] {safe_title} -> {entry['path']}{tags_str}")
    print("</memory-context>")


def _sanitize_title(title: str) -> str:
    """Sanitize a title for safe injection into prompt context."""
    # Strip control characters
    title = re.sub(r'[\x00-\x1f\x7f]', '', title)
    # Strip index-format injection markers
    title = title.replace(" -> ", " - ").replace("#tags:", "")
    # Truncate to 120 chars (matches write-side max_length)
    title = title.strip()[:120]
    return title
```

**Key details:**
- `<memory-context>` XML tags provide clear data boundaries
- `_sanitize_title()` re-applies sanitization on read path (defense in depth)
- Title truncated to 120 chars (matches Pydantic max_length on write side)
- `entry["raw"]` is NO LONGER used -- reconstructed from parsed/sanitized fields
- Tags are sorted for deterministic output

**Note:** The `_sanitize_title` function should be placed before `main()` in the file (e.g., after `check_recency` at line 153).

#### Also remove the now-unused trailing message

The old code had `print("Read the referenced files above...")` which is no longer needed -- the structured format is self-explanatory.

### Edge Cases
- **Title with embedded `</memory-context>`**: The angle brackets are preserved but since we're not in an XML parser, this is cosmetic; the key protection is that titles are sanitized and truncated
- **Title with `[SYSTEM]` prefix**: Not stripped (would need more aggressive filtering). However, Claude's instruction following is based on system prompt structure, not arbitrary `[SYSTEM]` tags in user context
- **Pre-sanitization entries**: Old entries written before write-side sanitization are cleaned on retrieval
- **Tags with injection attempts**: Tags are from `set()` (already parsed from index regex), not raw strings

### Interaction with other fixes
- Issue 1 (index rebuild): Rebuilt index uses sanitized titles from JSON source (write-side sanitization applies during original write)
- Issue 3 (max_inject clamp): Fewer injected entries = smaller injection surface

---

## Fix Interaction Matrix

| | Issue 1 (index) | Issue 2 (root) | Issue 3 (max_inject) | Issue 4 (lock) | Issue 5 (injection) |
|---|---|---|---|---|---|
| **Issue 1** | - | Independent | Independent | Lock dir name change | Rebuilt index is clean |
| **Issue 2** | Independent | - | Independent | Independent | Independent |
| **Issue 3** | Independent | Independent | - | Independent | Fewer entries = less surface |
| **Issue 4** | Rebuild vs lock: no contention | Independent | Independent | - | Independent |
| **Issue 5** | Uses parsed fields not raw | Independent | Independent | Independent | - |

## Implementation Order (recommended)

1. **Issue 2** (root resolution) -- smallest change, pure security fix, no dependencies
2. **Issue 3** (max_inject clamp) -- smallest change, self-contained
3. **Issue 5** (injection defense) -- retrieval output change, independent
4. **Issue 4** (locking) -- replaces lock mechanism, independent but testable
5. **Issue 1** (index rebuild) -- largest change footprint, touches 3 files + .gitignore

This order puts the simplest, most independent fixes first and the most complex last. Each fix can be tested independently.

## Backward Compatibility Summary

| Issue | Breaking Change? | Migration Needed? |
|---|---|---|
| 1 (index) | No -- index still works if present | Add to .gitignore; existing index.md still functions |
| 2 (root) | Yes for malformed paths | Callers with non-standard paths get clear error |
| 3 (max_inject) | No -- valid configs unchanged | Invalid configs get clamped with warning |
| 4 (lock) | Lock artifact changes | Old `.index.lock` file can be deleted; `.index.lockdir` used instead |
| 5 (injection) | Output format changes | Consumers parsing retrieval output need to handle `<memory-context>` tags |

## Test Requirements Per Fix

| Issue | Unit Tests | Integration Tests |
|---|---|---|
| 1 | Rebuild triggers when index missing; no rebuild when present | Retrieval works after gitignore + rebuild cycle |
| 2 | Paths with marker resolve correctly; paths without marker fail; relative/absolute paths | Write operations with valid/invalid target paths |
| 3 | Clamp values: -1, 0, 5, 20, 100, "five", null, 5.7, missing | Config with various max_inject values |
| 4 | Lock acquire/release; stale detection; timeout; concurrent access | Two writers operating simultaneously |
| 5 | Title sanitization function; output format; pre-sanitization entries | Retrieval of entries with injection-attempt titles |
