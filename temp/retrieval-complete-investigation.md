# claude-memory 플러그인 메모리 검색 시스템 완전 조사 보고서

**작성일**: 2026-02-19
**대상 버전**: v5.0.0
**조사 범위**: UserPromptSubmit 이벤트 → 메모리 컨텍스트 주입 전 과정

---

## 1. 전체 흐름 요약 (Overview)

### 1.1 전체 파이프라인 다이어그램

```
사용자가 프롬프트를 입력
         |
         v
[Claude Code] UserPromptSubmit 이벤트 발생
         |
         | stdin으로 JSON 전달:
         | { "user_prompt": "...", "cwd": "/path/to/project" }
         v
[hooks.json] matcher: "*" 매칭
         |
         v
[memory_retrieve.py] 실행 (timeout: 10s)
         |
         +---> stdin 비어있음?           ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> prompt 길이 < 10자?       ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> memory_root 결정
         |     (.claude/memory/)
         |
         +---> index.md 존재하지 않음?
         |     memory_root 존재함?       ---> memory_index.py --rebuild 호출
         |                                    (최대 10초 대기)
         |
         +---> index.md 여전히 없음?     ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> memory-config.json 읽기
         |     retrieval.enabled = false? ---> sys.exit(0) [컨텍스트 없음]
         |     max_inject = 0?            ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> index.md 파싱
         |     (parse_index_line() 호출)
         |
         +---> entries 비어있음?          ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> tokenize(user_prompt)
         |
         +---> prompt_words 비어있음?    ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> [Pass 1: 텍스트 매칭]
         |     score_entry() + score_description() 호출
         |     score > 0 인 엔트리만 수집
         |
         +---> scored 비어있음?          ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> 내림차순 정렬
         |     (score DESC, category priority ASC)
         |
         +---> [Pass 2: 딥 체크] (상위 20개)
         |     JSON 파일 읽기
         |     is_retired? → 제외
         |     is_recent? → +1점 보너스
         |
         +---> 20개 초과분: recency 없이 포함
         |
         +---> final 비어있음?           ---> sys.exit(0) [컨텍스트 없음]
         |
         +---> 재정렬 후 상위 max_inject개 선택
         |
         v
stdout으로 <memory-context> XML 블록 출력
         |
         v
[Claude Code] stdout 내용을 컨텍스트에 자동 주입
         |
         v
Claude가 프롬프트 처리 (메모리 컨텍스트 포함)
```

### 1.2 관련 파일 역할 요약

| 파일 | 역할 |
|------|------|
| `hooks/hooks.json` | UserPromptSubmit 훅 설정 (matcher, command, timeout) |
| `hooks/scripts/memory_retrieve.py` | 핵심 검색 스크립트 (363줄) |
| `hooks/scripts/memory_index.py` | 인덱스 관리 (rebuild, validate, query, health, gc) |
| `.claude/memory/index.md` | 경량 검색용 인덱스 파일 (derived artifact) |
| `.claude/memory/memory-config.json` | 설정 파일 (retrieval.*, categories.*) |
| `.claude/memory/<category>/*.json` | 실제 메모리 데이터 |

---

## 2. 트리거 메커니즘 (Hook Trigger)

### 2.1 hooks.json 설정

`hooks/hooks.json:43-55` 에 다음과 같이 정의되어 있다:

```json
"UserPromptSubmit": [
  {
    "matcher": "*",
    "hooks": [
      {
        "type": "command",
        "command": "python3 \"$CLAUDE_PLUGIN_ROOT/hooks/scripts/memory_retrieve.py\"",
        "timeout": 10,
        "statusMessage": "Retrieving relevant memories..."
      }
    ]
  }
]
```

- **matcher**: `"*"` -- 모든 프롬프트에서 트리거 (조건 없음)
- **type**: `"command"` -- 셸 커맨드로 실행
- **timeout**: `10`초 -- 10초 내에 완료되지 않으면 중단
- **statusMessage**: Claude Code UI에 "Retrieving relevant memories..." 표시
- **트리거 시점**: 사용자가 프롬프트를 제출하는 순간, Claude가 처리하기 *전에* 실행

### 2.2 stdin으로 전달되는 JSON 형식

`memory_retrieve.py:198-209` 에서 stdin을 파싱하는 코드:

```python
raw = sys.stdin.read()
if not raw.strip():
    sys.exit(0)
hook_input = json.loads(raw)

user_prompt = hook_input.get("user_prompt", "")
cwd = hook_input.get("cwd", os.getcwd())
```

Claude Code가 전달하는 JSON 구조:
```json
{
  "user_prompt": "사용자가 입력한 프롬프트 전체 텍스트",
  "cwd": "/현재/작업/디렉토리/경로"
}
```

- `user_prompt`: 사용자가 제출한 원문 그대로 (처리되지 않은 원시 텍스트)
- `cwd`: 현재 작업 디렉토리 (memory_root 계산에 사용됨)
- `cwd` 미제공 시 `os.getcwd()` fallback

### 2.3 출력 메커니즘

`memory_retrieve.py:352-358` 에서 stdout으로 XML 블록을 출력:

```python
print(f"<memory-context source=\".claude/memory/\"{desc_attr}>")
for _, _, entry in top:
    safe_title = _sanitize_title(entry["title"])
    ...
    print(f"- [{entry['category']}] {safe_title} -> {entry['path']}{tags_str}")
print("</memory-context>")
```

Claude Code는 훅의 `exit 0` 상태에서 stdout 내용을 **자동으로** Claude의 컨텍스트에 주입한다. 별도 전달 설정이 필요 없으며, 훅 타입이 `"command"` 이고 exit 코드가 0이면 stdout이 컨텍스트에 포함된다.

---

## 3. 인덱스 시스템 (Index System)

### 3.1 index.md 구조와 형식

index.md는 `memory_index.py:102-110` 의 `rebuild_index()` 함수가 생성하는 파일이다:

```markdown
# Memory Index

<!-- Auto-generated by memory_index.py. Do not edit manually. -->

- [DECISION] Use pydantic v2 for schema validation -> .claude/memory/decisions/use-pydantic-v2.json #tags:pydantic,validation,schema
- [CONSTRAINT] API rate limit 10 req/min -> .claude/memory/constraints/api-rate-limit.json #tags:api,rate-limit
- [PREFERENCE] Always use type hints in Python -> .claude/memory/preferences/python-type-hints.json #tags:python,typing
- [RUNBOOK] Fix ImportError for pydantic -> .claude/memory/runbooks/fix-pydantic-import.json #tags:pydantic,error,import
- [SESSION_SUMMARY] Implemented memory plugin v5 -> .claude/memory/sessions/session-2026-02.json #tags:plugin,memory
- [TECH_DEBT] Improve test coverage for retrieve -> .claude/memory/tech-debt/test-coverage.json #tags:testing,coverage
```

**인덱스 라인 형식 (enriched format)**:
```
- [CATEGORY] title -> path #tags:tag1,tag2,tag3
```

- `[CATEGORY]`: 대문자 카테고리 식별자 (DECISION, CONSTRAINT, PREFERENCE, RUNBOOK, SESSION_SUMMARY, TECH_DEBT)
- `title`: 메모리 제목 (공백 포함 가능)
- `->`: 경로 구분자 (고정 포맷, 보안상 중요)
- `path`: JSON 파일의 상대 경로 (프로젝트 루트 기준)
- `#tags:`: 태그 접두사 (선택적, enriched format)
- `tag1,tag2,...`: 쉼표 구분 태그 목록

### 3.2 자동 리빌드 로직 (derived artifact pattern)

`memory_retrieve.py:219-232`:

```python
# Rebuild index on demand if missing (derived artifact pattern).
# index.md may be .gitignored -- rebuild from authoritative JSON files.
if not index_path.exists() and memory_root.is_dir():
    import subprocess
    index_tool = Path(__file__).parent / "memory_index.py"
    if index_tool.exists():
        try:
            subprocess.run(
                [sys.executable, str(index_tool), "--rebuild", "--root", str(memory_root)],
                capture_output=True, timeout=10,
            )
        except subprocess.TimeoutExpired:
            pass
```

- **트리거 조건**: `index.md`가 없고 `memory_root` 디렉토리가 존재할 때
- **실행**: `memory_index.py --rebuild --root <memory_root>` subprocess 실행
- **타임아웃**: 10초 (초과 시 `TimeoutExpired` 예외 발생하지만 무시됨)
- **목적**: index.md를 .gitignore에 추가해도 자동 재생성

`memory_candidate.py:221-231` 에서도 동일한 패턴이 사용된다 (ACE 후보 선택 시).

### 3.3 memory_index.py의 scan_memories() → rebuild_index() 흐름

`memory_index.py:45-116`:

```python
def scan_memories(root: Path, include_inactive: bool = False) -> list[dict]:
    """모든 카테고리 폴더의 JSON 파일 스캔"""
    for category, folder in CATEGORY_FOLDERS.items():
        for json_file in sorted(folder_path.glob("*.json")):
            data = json.load(f)
            record_status = data.get("record_status", "active")
            # include_inactive=False(기본값)이면 active만 포함
            if not include_inactive and record_status != "active":
                continue
            # 메타데이터 추출: title, category, tags, rel_path
            rel_path = json_file.relative_to(root.parent.parent)
            memories.append({...})
    return memories

def rebuild_index(root: Path) -> None:
    """index.md 재생성"""
    memories = scan_memories(root, include_inactive=False)
    # 카테고리→제목 순으로 정렬
    memories.sort(key=lambda m: (m["display"], m["title"].lower()))
    # 각 엔트리를 enriched 포맷으로 작성
    for m in memories:
        line = f"- [{m['display']}] {m['title']} -> {m['path']}"
        if m["tags"]:
            line += f" #tags:{','.join(m['tags'])}"
        lines.append(line)
    # index.md에 저장
    index_path.write_text(...)
```

**핵심 설계**: index.md는 JSON 파일들의 파생 산출물(derived artifact)이다. JSON 파일이 진짜 source of truth이며, index.md는 빠른 선형 스캔을 위한 캐시이다.

---

## 4. 토큰화 & 매칭 (Tokenization & Matching)

### 4.1 tokenize() 함수 상세

`memory_retrieve.py:60-66`:

```python
_TOKEN_RE = re.compile(r"[a-z0-9]+")

def tokenize(text: str) -> set[str]:
    """Extract meaningful lowercase tokens from text."""
    tokens = set()
    for word in _TOKEN_RE.findall(text.lower()):
        if word not in STOP_WORDS and len(word) > 2:
            tokens.add(word)
    return tokens
```

처리 단계:
1. **소문자 변환**: `text.lower()`
2. **토큰 추출**: `[a-z0-9]+` regex -- 알파벳과 숫자만, 특수문자 제거
3. **stop words 제거**: 32개 불용어 집합에서 필터링 (a, an, the, is, ...)
4. **길이 필터**: 3자 미만 제거 (`len(word) > 2`, 즉 최소 3자)
5. **set으로 반환**: 중복 제거 + 집합 연산 최적화

**stop words 목록** (`memory_retrieve.py:21-32`):
```python
STOP_WORDS = frozenset({
    "a", "an", "the", "is", "was", "are", "were", "be", "been", "being",
    "do", "does", "did", "have", "has", "had", "will", "would", "could",
    "can", "should", "may", "might", "shall", "must",
    "i", "you", "we", "they", "he", "she", "it", "me", "my", "your",
    "this", "that", "these", "those", "what", "which", "who", "whom",
    "how", "when", "where", "why", "if", "then", "else", "so",
    "and", "or", "but", "not", "no", "yes", "to", "of", "in", "on",
    "at", "for", "with", "from", "by", "about", "up", "out", "into",
    "just", "also", "very", "too", "let", "please", "help", "need",
    "want", "know", "think", "make", "like", "use", "get", "go", "see",
})
```

### 4.2 parse_index_line() regex 패턴 상세

`memory_retrieve.py:44-88`:

```python
_INDEX_RE = re.compile(
    r"^-\s+\[([A-Z_]+)\]\s+(.+?)\s+->\s+(\S+)"
    r"(?:\s+#tags:(.+))?$"
)
```

정규식 분해:
```
^                  -- 줄 시작
-\s+               -- 대시 + 공백(들)
\[([A-Z_]+)\]      -- 캡처 그룹 1: 대문자+언더스코어 카테고리명 (예: DECISION, TECH_DEBT)
\s+                -- 공백(들)
(.+?)              -- 캡처 그룹 2: 타이틀 (non-greedy, lazy)
\s+                -- 공백(들)
->                 -- 경로 구분자 화살표
\s+                -- 공백(들)
(\S+)              -- 캡처 그룹 3: 경로 (공백 없는 문자열)
(?:                -- 선택적 그룹 (non-capturing)
  \s+#tags:        -- 공백 + "#tags:" 리터럴
  (.+)             -- 캡처 그룹 4: 태그 문자열
)?                 -- 그룹 선택적
$                  -- 줄 끝
```

파싱 결과 dict:
```python
{
    "category": "DECISION",          # m.group(1)
    "title": "Use pydantic v2",      # m.group(2).strip()
    "path": ".claude/memory/decisions/use-pydantic-v2.json",  # m.group(3)
    "tags": {"pydantic", "validation"},  # set from m.group(4)
    "raw": "- [DECISION] Use pydantic v2 -> ...",
}
```

태그는 소문자로 변환된다 (`memory_retrieve.py:80`):
```python
tags = [t.strip().lower() for t in tags_str.split(",") if t.strip()] if tags_str else []
```

### 4.3 실제 토큰화 예시

**예시 1**: 사용자 프롬프트 `"How do I fix the pydantic import error?"`

```
1. 소문자: "how do i fix the pydantic import error?"
2. regex 추출: ["how", "do", "fix", "the", "pydantic", "import", "error"]
3. stop words 제거: ["fix", "pydantic", "import", "error"]
   (how, do, the 제거)
4. 길이 필터: ["fix", "pydantic", "import", "error"]
   (모두 3자 이상)
5. 결과 set: {"fix", "pydantic", "import", "error"}
```

**예시 2**: 사용자 프롬프트 `"go use it"`

```
1. 소문자: "go use it"
2. regex 추출: ["go", "use", "it"]
3. stop words 제거: [] (모두 stop words)
4. 결과 set: {}  → tokenize() returns empty set
→ main()에서 sys.exit(0) (라인 288)
```

---

## 5. 스코어링 알고리즘 (Scoring Algorithm)

### 5.1 Pass 1: 텍스트 매칭

#### score_entry() 함수 (`memory_retrieve.py:90-117`)

```python
def score_entry(prompt_words: set[str], entry: dict) -> int:
    title_tokens = tokenize(entry["title"])  # 타이틀도 동일하게 토큰화
    entry_tags = entry["tags"]               # 이미 소문자 set

    # 타이틀 정확 일치: 2점/단어
    exact_title = prompt_words & title_tokens
    score = len(exact_title) * 2

    # 태그 정확 일치: 3점/태그
    exact_tags = prompt_words & entry_tags
    score += len(exact_tags) * 3

    # 접두사 매칭 (4자 이상, 이미 매칭된 토큰 제외): 1점
    already_matched = exact_title | exact_tags
    combined_targets = title_tokens | entry_tags
    for pw in prompt_words - already_matched:
        if len(pw) >= 4:
            if any(target.startswith(pw) for target in combined_targets):
                score += 1

    return score
```

**점수표**:

| 매칭 유형 | 점수 | 조건 |
|-----------|------|------|
| 타이틀 단어 정확 일치 | +2점/단어 | `prompt_word ∈ title_tokens` |
| 태그 정확 일치 | +3점/태그 | `prompt_word ∈ entry_tags` |
| 접두사 매칭 (타이틀+태그) | +1점 | 4자 이상 prompt_word, `target.startswith(prompt_word)`, 미매칭 토큰만 |

**중요**: 접두사 매칭은 이미 exact match된 토큰을 재채점하지 않는다 (`prompt_words - already_matched`).

#### score_description() 함수 (`memory_retrieve.py:120-144`)

```python
def score_description(prompt_words: set[str], description_tokens: set[str]) -> int:
    score = 0.0

    # 정확 일치: 1점/단어
    exact = prompt_words & description_tokens
    score += len(exact) * 1.0

    # 접두사 매칭 (미매칭 4자 이상 토큰): 0.5점
    for pw in prompt_words - already_matched:
        if len(pw) >= 4:
            if any(dt.startswith(pw) for dt in description_tokens):
                score += 0.5

    # 최대 2점으로 제한 (설명이 타이틀/태그를 압도하지 못하도록)
    return min(2, int(score))
```

**점수표**:

| 매칭 유형 | 점수 | 비고 |
|-----------|------|------|
| 카테고리 설명 단어 정확 일치 | +1점/단어 | float → int 버림 |
| 카테고리 설명 접두사 매칭 | +0.5점 | float → int 버림 |
| 최대 cap | 2점 | `min(2, int(score))` |

#### 카테고리 우선순위 (`memory_retrieve.py:34-42`)

동점(같은 점수)일 때 이 순서로 정렬된다:

```python
CATEGORY_PRIORITY = {
    "DECISION": 1,      # 가장 높은 우선순위 (가장 먼저 주입)
    "CONSTRAINT": 2,
    "PREFERENCE": 3,
    "RUNBOOK": 4,
    "TECH_DEBT": 5,
    "SESSION_SUMMARY": 6,  # 가장 낮은 우선순위
}
```

Pass 1 완료 후 정렬: `scored.sort(key=lambda x: (-x[0], x[1]))` (`memory_retrieve.py:311`)

### 5.2 Pass 2: 딥 체크 (`memory_retrieve.py:313-336`)

```python
_DEEP_CHECK_LIMIT = 20   # 상위 20개만 딥 체크
_RECENCY_DAYS = 30       # 30일 이내 = 최근

project_root = memory_root.parent.parent  # .claude/memory → 프로젝트 루트
final = []
for text_score, priority, entry in scored[:_DEEP_CHECK_LIMIT]:
    file_path = project_root / entry["path"]
    is_retired, is_recent = check_recency(file_path)

    if is_retired:
        continue  # retired 엔트리 제외 (방어적 처리)

    final_score = text_score + (1 if is_recent else 0)  # recency 보너스
    final.append((final_score, priority, entry))

# 20개 초과분: recency 없이 포함 (JSON 파일 미읽음)
for text_score, priority, entry in scored[_DEEP_CHECK_LIMIT:]:
    final.append((text_score, priority, entry))
```

#### check_recency() 함수 (`memory_retrieve.py:147-180`)

```python
def check_recency(file_path: Path) -> tuple[bool, bool]:
    """Returns (is_retired, is_recent)"""
    data = json.load(f)

    record_status = data.get("record_status", "active")
    if record_status == "retired":
        return True, False  # retired는 즉시 반환

    updated_at_str = data.get("updated_at")
    updated_at = datetime.fromisoformat(updated_at_str)
    # timezone-aware 비교
    age_days = (now - updated_at).days
    return False, age_days <= _RECENCY_DAYS  # 30일 이내면 is_recent=True
```

파일 읽기 실패 시 `(False, False)` 반환 (방어적).

### 5.3 구체적 계산 예시

#### 예시 A: 프롬프트 `"fix pydantic import error in tests"`

```
prompt_words = tokenize("fix pydantic import error in tests")
            = {"fix", "pydantic", "import", "error", "tests"}
```

**인덱스 엔트리 1**: `- [RUNBOOK] Fix pydantic ImportError -> ... #tags:pydantic,import,error`
```
title_tokens = tokenize("Fix pydantic ImportError")
             = {"fix", "pydantic", "importerror"}

exact_title = {"fix", "pydantic"} & {"fix", "pydantic", "importerror"}
            = {"fix", "pydantic"} → 2개 × 2점 = 4점

exact_tags = {"fix", "pydantic", "import", "error", "tests"} & {"pydantic", "import", "error"}
           = {"pydantic", "import", "error"} → 3개 × 3점 = 9점

already_matched = {"fix", "pydantic", "import", "error"}
remaining = {"tests"} (4자, 매칭 없음) → 0점

score_entry = 4 + 9 = 13점
```

카테고리 설명: `"Step-by-step procedures for diagnosing and fixing specific errors or issues"`
```
desc_tokens = tokenize("Step-by-step procedures for diagnosing...")
            = {"step", "procedures", "diagnosing", "fixing", "specific", "errors", "issues"}

exact_desc = {"fix", "pydantic", "import", "error", "tests"} & {"step", ..., "errors", "issues"}
           → "error" vs "errors": 불일치 (정확 일치 아님)
           → "fix" vs "fixing": 불일치 (정확 일치 아님)

prefix = "fix" (3자) → 4자 미만이므로 제외!
         "pydantic" (8자) → any desc_token.startswith("pydantic")? → 없음
         "import" (6자) → any desc_token.startswith("import")? → 없음
         "error" (5자) → any("errors".startswith("error"))? → True! +0.5점
         "tests" (5자) → 없음

score_description = int(0.5) = 0 (버림!)
총 score = 13 + 0 = 13점
```

Pass 2 딥 체크:
```
updated_at = "2026-02-15T10:00:00Z" (4일 전)
age_days = 4 ≤ 30 → is_recent = True → +1점
최종 score = 14점
```

#### 예시 B: 프롬프트 `"authentication policy"`

```
prompt_words = {"authentication", "policy"}
```

**인덱스 엔트리**: `- [CONSTRAINT] API auth rate limit -> ... #tags:api,auth,rate`
```
title_tokens = tokenize("API auth rate limit") = {"api", "auth", "rate", "limit"}

exact_title = {"authentication", "policy"} & {"api", "auth", "rate", "limit"}
            = {} → 0점

exact_tags = {"authentication", "policy"} & {"api", "auth", "rate"}
           = {} → 0점

prefix: "authentication" (14자) → "auth".startswith("authentication")? → False!
        (접두사 방향이 반대: target이 prompt_word로 시작해야 함)
        "policy" (6자) → any target.startswith("policy")? → 없음

score_entry = 0점 → 이 엔트리는 scored에 포함되지 않음
```

**참고**: 접두사 매칭은 `target.startswith(prompt_word)` 방향이다. 즉, 인덱스의 토큰이 프롬프트 단어로 *시작*해야 한다. `"auth"`는 `"authentication"`으로 시작하지 않으므로 매칭 실패.

#### 예시 C: 프롬프트 `"always prefer type hint convention"`

```
prompt_words = tokenize("always prefer type hint convention")
= {"always", "prefer", "type", "hint", "convention"}
(stop words 없음, 모두 3자 이상)
```

**인덱스 엔트리**: `- [PREFERENCE] Always use type hints in Python -> ... #tags:python,typing`
```
title_tokens = tokenize("Always use type hints in Python")
             = {"always", "type", "hints", "python"}
             ("use", "in" 제거됨 - stop words)

exact_title = {"always", "prefer", "type", "hint", "convention"}
            & {"always", "type", "hints", "python"}
            = {"always", "type"} → 2개 × 2점 = 4점

exact_tags = {"always", "prefer", "type", "hint", "convention"}
           & {"python", "typing"}
           = {} → 0점

already_matched = {"always", "type"}
remaining = {"prefer", "hint", "convention"}

prefix checks:
  "prefer" (6자) → "python".startswith("prefer")? No. "typing".startswith("prefer")? No. → 0점
  "hint" (4자) → "hints".startswith("hint")? Yes! → +1점
  "convention" (10자) → 없음

score_entry = 4 + 0 + 1 = 5점
```

카테고리 설명: `"User conventions, tool choices, coding standards, and workflow preferences"`
```
desc_tokens = {"user", "conventions", "tool", "choices", "coding", "standards", "workflow", "preferences"}

exact_desc = {"prefer", "hint", "convention"} & {"user", "conventions", ...}
  "convention" vs "conventions": 불일치

prefix: "prefer" (6자) → "preferences".startswith("prefer")? Yes! → +0.5점
        "hint" (4자) → 없음
        "convention" (10자) → "conventions".startswith("convention")? Yes! → +0.5점

score_description = int(0.5 + 0.5) = int(1.0) = 1점
총 score = 5 + 1 = 6점
```

---

## 6. 출력 형식 (Output Format)

### 6.1 `<memory-context>` XML 블록의 정확한 구조

`memory_retrieve.py:342-358`:

```python
# descriptions 속성 구성
desc_attr = ""
if category_descriptions:
    desc_parts = []
    for cat_key, desc in sorted(category_descriptions.items()):
        safe_desc = _sanitize_title(desc)
        desc_parts.append(f"{cat_key}={safe_desc}")
    if desc_parts:
        desc_attr = " descriptions=\"" + "; ".join(desc_parts) + "\""

print(f"<memory-context source=\".claude/memory/\"{desc_attr}>")
for _, _, entry in top:
    safe_title = _sanitize_title(entry["title"])
    tags = entry.get("tags", set())
    tags_str = f" #tags:{','.join(sorted(tags))}" if tags else ""
    print(f"- [{entry['category']}] {safe_title} -> {entry['path']}{tags_str}")
print("</memory-context>")
```

실제 출력 예시:
```xml
<memory-context source=".claude/memory/" descriptions="constraint=External limitations, platform restrictions...; decision=Architectural and technical choices...">
- [RUNBOOK] Fix pydantic ImportError -> .claude/memory/runbooks/fix-pydantic-import.json #tags:error,import,pydantic
- [DECISION] Use pydantic v2 for schema validation -> .claude/memory/decisions/use-pydantic-v2.json #tags:pydantic,schema,validation
</memory-context>
```

구조 설명:
- `source` 속성: 항상 `".claude/memory/"` 고정
- `descriptions` 속성: 카테고리 설명 전체 (카테고리별 설명이 config에 있을 때만 포함)
  - 형식: `"cat1=desc1; cat2=desc2; ..."` (정렬된 키 순서)
  - 각 설명도 `_sanitize_title()` 처리됨
- 본문: 한 줄씩 메모리 엔트리 (인덱스와 동일한 포맷)
- 태그: `sorted(tags)` 알파벳 순 정렬

### 6.2 `_sanitize_title()` 함수 상세 (`memory_retrieve.py:183-195`)

```python
def _sanitize_title(title: str) -> str:
    # 1. 제어 문자 제거 (0x00-0x1f, 0x7f)
    title = re.sub(r'[\x00-\x1f\x7f]', '', title)

    # 2. Zero-width, 양방향 재정의, 유니코드 태그 문자 제거
    title = re.sub(r'[\u200b-\u200f\u2028-\u202f\u2060-\u2069\ufeff\U000e0000-\U000e007f]', '', title)

    # 3. 인덱스 포맷 주입 마커 제거
    title = title.replace(" -> ", " - ").replace("#tags:", "")

    # 4. XML 특수문자 이스케이프
    title = title.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', '&quot;')

    # 5. 120자로 자름 (쓰기 측 max_length와 일치)
    title = title.strip()[:120]
    return title
```

이 함수는 읽기 측(retrieval-side) 방어이다. 쓰기 측(memory_write.py)에서 이미 sanitize했지만, defense-in-depth 원칙에 따라 재처리한다.

### 6.3 Claude 컨텍스트 주입 메커니즘

훅 타입 `"command"` + exit 코드 0 + stdout 내용 → Claude Code가 자동으로 다음 처리:
- stdout 내용이 사용자 메시지 전에 Claude의 컨텍스트에 삽입됨
- Claude는 `<memory-context>` 블록을 읽고 관련 과거 메모리를 인식함
- 별도 설정 불필요 (Claude Code의 훅 프로토콜)

---

## 7. 설정의 영향 (Configuration)

### 7.1 설정 파일 위치 및 로딩

`memory_retrieve.py:237-265`:

```python
config_path = memory_root / "memory-config.json"  # .claude/memory/memory-config.json
if config_path.exists():
    config = json.load(f)
    retrieval = config.get("retrieval", {})
    ...
```

### 7.2 retrieval.enabled

```python
if not retrieval.get("enabled", True):
    sys.exit(0)
```

- 기본값: `True`
- `false`로 설정 시: 즉시 종료, 메모리 주입 없음
- 기본 설정에서 이 키는 없으므로 기본값 `True` 사용됨 (default config에서 확인: `retrieval.enabled` 키 없음)

### 7.3 retrieval.max_inject

```python
max_inject = 5  # 하드코딩 기본값
raw_inject = retrieval.get("max_inject", 5)
try:
    max_inject = max(0, min(20, int(raw_inject)))
except (ValueError, TypeError, OverflowError):
    max_inject = 5
    print(f"[WARN] Invalid max_inject value: {raw_inject!r}; using default 5", file=sys.stderr)
```

- **기본값**: 5 (`memory-config.default.json:51`)
- **유효 범위**: 0 ~ 20 (강제 클램핑)
- **0이면**: 즉시 종료 (`if max_inject == 0: sys.exit(0)`)
- **파싱 실패 시**: 기본값 5 사용 + stderr 경고

### 7.4 categories.*.description

```python
categories_raw = config.get("categories", {})
for cat_key, cat_val in categories_raw.items():
    desc = cat_val.get("description", "")
    category_descriptions[cat_key.lower()] = desc[:500]  # 500자 제한
```

- 각 카테고리 설명은 `score_description()`에서 추가 점수 제공 (최대 +2점)
- `desc_tokens_by_cat`으로 사전 토큰화 (`memory_retrieve.py:291-293`)
- 출력의 `descriptions` 속성에 포함됨

**기본 설명값** (`memory-config.default.json`):

| 카테고리 | description |
|----------|-------------|
| session_summary | "High-level summary of work done in a coding session..." |
| decision | "Architectural and technical choices with rationale..." |
| runbook | "Step-by-step procedures for diagnosing and fixing..." |
| constraint | "External limitations, platform restrictions, and hard boundaries..." |
| tech_debt | "Known shortcuts, deferred work, and technical cleanup tasks..." |
| preference | "User conventions, tool choices, coding standards, and workflow preferences" |

### 7.5 match_strategy (agent-interpreted)

```json
"retrieval": {
    "max_inject": 5,
    "match_strategy": "title_tags"
}
```

`match_strategy`는 **agent-interpreted** 설정이다. Python 스크립트에서 읽지 않으며, LLM(SKILL.md 지침)이 읽는 설정이다. 현재 값 `"title_tags"`는 Python 구현의 실제 동작을 문서화한 것이다.

---

## 8. 조기 종료 조건 (Early Exit Conditions)

`memory_retrieve.py`의 모든 `sys.exit(0)` 경로:

| 라인 | 조건 | 설명 |
|------|------|------|
| 203 | `not raw.strip()` | stdin 비어있음 |
| 206 | `json.JSONDecodeError, EOFError` | stdin JSON 파싱 실패 |
| 213 | `len(user_prompt.strip()) < 10` | 프롬프트 10자 미만 (인사, ack 등) |
| 234 | `not index_path.exists()` | index.md 없음 (rebuild 실패 포함) |
| 246 | `not retrieval.get("enabled", True)` | retrieval 비활성화 |
| 268 | `max_inject == 0` | 주입 수 0 |
| 279 | `OSError` (index.md 읽기 실패) | 파일 읽기 오류 |
| 281 | `not entries` | 파싱된 엔트리 없음 |
| 288 | `not prompt_words` | 토큰화 결과 없음 (모두 stop words/짧은 단어) |
| 307 | `not scored` | Pass 1 매칭 결과 없음 (score > 0 없음) |
| 333 | `not final` | Pass 2 후 결과 없음 (모두 retired) |

exit 코드는 항상 0 (Claude Code 훅 컨벤션: 비0은 훅 오류로 처리됨).

---

## 9. Triage(저장)와 Retrieval(조회)의 비교

### 9.1 Triage (memory_triage.py) - 저장 결정

**목적**: 세션 종료 시 대화 내용에서 저장할 가치 있는 정보 감지

```
입력: 대화 트랜스크립트 전체 (최대 50개 메시지)
알고리즘:
  - primary regex 패턴 매칭 (예: r"\b(decided|chose|selected)\b")
  - co-occurrence booster (4줄 윈도우 내 근접 키워드)
  - 정규화된 점수 [0.0, 1.0]
  - 카테고리별 임계값 비교 (기본 0.4-0.6)
출력: 트리거된 카테고리 목록 + 컨텍스트 파일
```

**DECISION 카테고리 예시**:
```python
primary_weight = 0.3      # 단독 primary 매칭당
boosted_weight = 0.5      # co-occurrence booster 있을 때
max_primary = 3           # 최대 3개 primary 반영
max_boosted = 2           # 최대 2개 boosted 반영
denominator = 1.9         # 정규화 (3×0.3 + 2×0.5 = 1.9)
```

### 9.2 Retrieval (memory_retrieve.py) - 조회

**목적**: 사용자 프롬프트 처리 전 관련 과거 메모리 주입

```
입력: 현재 사용자 프롬프트 (단일 문장)
알고리즘:
  - 키워드 토큰화 (regex, stop words, 길이 필터)
  - 인덱스 라인과 토큰 집합 교차
  - 정수 점수 (비정규화)
  - 재현성 보너스 (JSON 파일 읽기, 30일)
출력: 상위 max_inject개 엔트리 XML 블록
```

### 9.3 score_entry() 비교: memory_candidate.py vs memory_retrieve.py

두 파일의 `score_entry()` 는 거의 동일하지만 미묘한 차이가 있다:

| 측면 | memory_retrieve.py | memory_candidate.py |
|------|-------------------|---------------------|
| 입력 | `prompt_words` (사용자 프롬프트 토큰) | `new_info_tokens` (새 정보 토큰) |
| 타이틀 정확 일치 | 2점/단어 | 2점/단어 |
| 태그 정확 일치 | 3점/태그 | 3점/태그 |
| 접두사 매칭 대상 | `title_tokens | entry_tags` | `title_tokens | entry_tags_lower` |
| 태그 소문자화 | 이미 소문자 (parse_index_line에서) | 명시적 `{t.lower() for t in entry["tags"]}` |
| 설명 점수 추가 | Yes (`score_description()`) | No |
| 임계값 (최소 점수) | 0보다 크면 포함 | 3 이상이어야 후보 |

**비대칭 이유 분석**:
- **Triage** (저장)는 관대해야 한다: 놓치는 것보다 과포착이 낫다
- **Retrieval** (조회)는 정밀해야 한다: 관련 없는 메모리 주입은 컨텍스트를 오염시킴
- **Candidate** (ACE)는 중복 방지가 목적: 점수 3 이상만 후보로 인정 (최소 1개 태그 일치 + α)

### 9.4 스코어링 복잡도 비교

```
Triage:    regex 패턴 + 슬라이딩 윈도우 co-occurrence + 정규화
Retrieval: set 교차(O(1)) + 접두사 루프 + recency JSON I/O
Candidate: set 교차(O(1)) + 접두사 루프 (JSON I/O는 별도 build_excerpt)
```

Triage가 가장 복잡하고 (세션 전체 텍스트 처리), Retrieval이 가장 빠르게 설계되어 있다 (단일 프롬프트, 10초 타임아웃).

---

## 10. 보안 분석 (Security)

### 10.1 Title Sanitization 체인

```
[memory_write.py - 쓰기 측] → [memory_index.py - 인덱스 재빌드] → [memory_retrieve.py - 읽기 측]
```

**쓰기 측 (memory_write.py)**:
- Pydantic 모델에서 title max_length=120
- 쓰기 시 sanitize (제어문자, ` -> ` → ` - `, `#tags:` 제거)

**인덱스 재빌드 (memory_index.py)**:
- 이미 sanitized된 JSON에서 title 직접 읽음
- **별도 재sanitize 없음** (CLAUDE.md의 "remaining gap" 언급)

**읽기 측 (memory_retrieve.py)**:
- `_sanitize_title()` 함수로 defense-in-depth 재처리
- 이 함수가 마지막 방어선

### 10.2 인덱스 포맷 주입 위협

취약 경로: 타이틀에 ` -> ` 또는 `#tags:` 포함 시

예시 악성 타이틀: `"normal title -> /etc/passwd #tags:evil"`

**방어**:
1. **쓰기 측**: `memory_write.py`가 ` -> ` → ` - ` 치환
2. **읽기 측**: `_sanitize_title()`가 동일 치환 (라인 190)
3. **인덱스 파싱**: `_INDEX_RE`의 lazy `(.+?)`는 첫 번째 ` -> ` 이후를 경로로 취급

하지만 `_INDEX_RE`는 `(.+?)` (non-greedy)를 사용하므로, 타이틀 내 ` -> ` 문자열이 남아있으면 파싱이 잘못될 수 있다. 이것이 write-side sanitization이 중요한 이유이다.

### 10.3 XML 경계 이탈 방어

`_sanitize_title()` 라인 192:
```python
title = title.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', '&quot;')
```

`<memory-context>` XML 블록 안에 `<`, `>`, `&`, `"` 를 포함하는 타이틀이 삽입될 경우 XML 구조를 깨뜨릴 수 있는 위험을 차단한다.

### 10.4 max_inject 클램핑

```python
max_inject = max(0, min(20, int(raw_inject)))
```

- 음수 → 0 (즉시 exit)
- 20 초과 → 20 (컨텍스트 폭발 방지)
- 비정수 → 기본값 5 (ValueError/TypeError 처리)
- 오버플로우 → 기본값 5 (OverflowError 처리)

### 10.5 경로 안전성

`memory_retrieve.py:315`:
```python
project_root = memory_root.parent.parent
file_path = project_root / entry["path"]
```

경로는 인덱스에서 읽은 상대 경로를 프로젝트 루트에 결합한다. `memory_candidate.py:340-344` 처럼 명시적인 `relative_to()` 안전성 검사는 없다. 인덱스의 경로가 `../../etc/passwd` 형태이면 경로 이탈 가능성이 있다 (이는 잠재적 취약점).

### 10.6 Unicode 스테가노그래피 방어

```python
# Zero-width, bidirectional override, tag characters 제거
title = re.sub(r'[\u200b-\u200f\u2028-\u202f\u2060-\u2069\ufeff\U000e0000-\U000e007f]', '', title)
```

보이지 않는 Unicode 문자를 통한 프롬프트 인젝션을 차단한다.

---

## 11. 한계점 & 개선 가능성 (Limitations)

### 11.1 키워드 매칭의 한계

현재 구현은 **정확 키워드 매칭 + 접두사 매칭**만 지원한다:
- **동의어 불가**: "error" 검색 시 "bug", "issue", "problem"은 매칭되지 않음
- **의미 검색 불가**: 벡터 임베딩 없음, semantic similarity 없음
- **형태소 분석 없음**: "fixing"과 "fix"는 별개 토큰

**우회 방법**: 태그를 동의어로 활용하거나, 타이틀을 여러 형태로 작성.

### 11.2 단일 프롬프트만 고려

`user_prompt` 필드 하나만 토큰화한다. 이전 대화 내용, 최근 파일 편집 내용, 활성 도구 등 풍부한 컨텍스트를 활용하지 않는다. 짧고 모호한 프롬프트(예: "같은 방식으로 해줘")는 관련 메모리를 찾지 못할 수 있다.

### 11.3 선형 스캔의 확장성

모든 인덱스 엔트리를 순차적으로 스캔한다:

```
O(N × M) 시간 복잡도
  N = 인덱스 엔트리 수
  M = 접두사 매칭 루프 (prompt_words × combined_targets)
```

카테고리별 최대 100개 메모리 × 6 카테고리 = 최대 600개 엔트리. 현재 규모에서는 문제없지만, 수천 개 이상이면 성능 저하 가능.

### 11.4 딥 체크 20개 제한으로 인한 누락

`_DEEP_CHECK_LIMIT = 20` 으로 상위 20개 이후 엔트리는:
- JSON 파일을 읽지 않음 → retired 상태 확인 불가
- recency 보너스 없음
- 결과적으로 retired 메모리가 21번째 이후에 있으면 출력될 수 있음

예외적이지만, retired 메모리가 점수는 높고 top 20을 초과하는 경우 방어 미흡.

### 11.5 인덱스 동기화 지연

`memory_write.py`가 JSON 파일을 저장할 때 index.md를 즉시 업데이트하지 않으면, 다음 `rebuild_index()` 호출 전까지 새 메모리가 검색되지 않는다. 이는 index가 derived artifact 패턴이기 때문에 허용된 설계 트레이드오프이다.

### 11.6 설명 점수의 상한이 낮음

카테고리 설명 매칭의 최대 기여는 2점이다. 타이틀 매칭(2점/단어)이나 태그 매칭(3점/태그)에 비해 낮아서, 설명이 프롬프트와 매우 잘 맞아도 타이틀/태그 미매칭을 보완하기 어렵다.

---

## 12. 자가비판 (Self-Critique)

### 12.1 이 분석에서 놓쳤을 수 있는 것

1. **실제 index.md 파일 미확인**: 현재 프로젝트에 실제 메모리 데이터가 없어 `scan_memories()`의 실제 출력을 검증하지 못했다. 태그 소문자화가 JSON에서 읽을 때 이미 소문자인지 확인하지 못했다.

2. **memory_write.py의 sanitization 코드 미확인**: 쓰기 측 sanitize 로직의 정확한 구현을 읽지 않았다. CLAUDE.md에서 설명한 내용과 일치하는지 직접 코드로 검증하지 못했다.

3. **Claude Code 훅 프로토콜 상세 미확인**: stdout이 컨텍스트에 어떻게 주입되는지 Claude Code 내부 구현을 확인하지 못했다. 훅 문서에서 설명된 내용을 신뢰했다.

4. **memory_validate_hook.py 미검토**: PostToolUse 검증 훅의 내부 로직을 이번 조사에 포함하지 않았다. quarantine 동작이 retrieval에 간접 영향을 줄 수 있다.

### 12.2 확인하지 못한 가정

1. **경로 이탈 가능성**: `project_root / entry["path"]`가 실제로 프로젝트 경계 밖으로 나갈 수 있는지 테스트하지 않았다. `memory_candidate.py`는 `relative_to()` 체크를 하는 반면 `memory_retrieve.py`는 하지 않는다. 실제 악용 가능성은 미확인.

2. **인덱스 재빌드 경쟁 조건**: 여러 프롬프트가 동시에 제출되어 여러 `memory_retrieve.py` 프로세스가 동시에 `memory_index.py --rebuild`를 호출할 경우 파일 쓰기 경합이 발생할 수 있다. `rebuild_index()`가 원자적 쓰기를 하는지 확인하지 않았다.

3. **`int(score)`의 버림 동작**: `score_description()`에서 `int(score)`는 Python에서 버림(truncation)이다. `min(2, int(0.9))` = 0이 된다. 이것이 의도된 것인지 (1점 미만은 제로), 아니면 반올림이 더 적절한지 검증하지 못했다.

### 12.3 추가 조사가 필요한 영역

1. **memory_write.py의 완전한 쓰기 파이프라인**: anti-resurrection, OCC, merge protection 로직의 실제 구현 코드 검토

2. **인덱스 자동 업데이트**: `memory_write.py` create/update 후 index.md를 즉시 재빌드하는지, 아니면 다음 retrieval hook 실행 시 on-demand로만 하는지

3. **실제 성능 프로파일링**: 500개 메모리 기준 retrieval hook 실행 시간 측정

4. **테스트 커버리지 확인**: `tests/test_memory_triage.py`, `tests/test_memory_write.py` 등이 위에서 분석한 엣지 케이스를 실제로 커버하는지

5. **Unicode 정규화**: `_sanitize_title()`이 NFC/NFD 정규화를 하지 않는다. 조합형 Unicode 문자를 통한 우회 가능성 미검토.

---

## 부록: 핵심 함수 참조표

| 함수 | 파일 | 라인 | 역할 |
|------|------|------|------|
| `main()` | memory_retrieve.py | 198 | 진입점, 전체 파이프라인 |
| `tokenize()` | memory_retrieve.py | 60 | 텍스트 → 토큰 집합 |
| `parse_index_line()` | memory_retrieve.py | 69 | 인덱스 라인 → dict |
| `score_entry()` | memory_retrieve.py | 90 | 엔트리 텍스트 매칭 점수 |
| `score_description()` | memory_retrieve.py | 120 | 카테고리 설명 매칭 점수 |
| `check_recency()` | memory_retrieve.py | 147 | JSON 파일 recency/retired 확인 |
| `_sanitize_title()` | memory_retrieve.py | 183 | 타이틀 보안 sanitize |
| `scan_memories()` | memory_index.py | 45 | JSON 파일 전체 스캔 |
| `rebuild_index()` | memory_index.py | 89 | index.md 재생성 |
| `score_entry()` | memory_candidate.py | 114 | ACE 후보 매칭 점수 (비교용) |
| `score_text_category()` | memory_triage.py | 332 | triage 카테고리 점수 (비교용) |

---

*이 보고서는 소스 코드 직접 분석을 기반으로 작성되었으며, 코드 변경 시 내용이 달라질 수 있다.*
