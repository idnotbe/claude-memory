{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory SESSION_SUMMARY capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and session_summary.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nDid meaningful work get completed or did project state change significantly? (Skip if the session was only reading, exploring, or asking questions without producing results.)\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to find any existing session_summary entry\n2. Only keep the LATEST session summary -- overwrite the previous session file if one exists\n3. Generate a descriptive kebab-case filename slug reflecting current work (not generic)\n4. Write JSON file to .claude/memory/sessions/{slug}.json\n5. Update index.md: replace previous session_summary line or add new one\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"session_summary\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"goal\": \"<what session aimed to accomplish>\",\n    \"outcome\": \"<success|partial|blocked|abandoned>\",\n    \"completed\": [\"<tasks confirmed done>\"],\n    \"in_progress\": [\"<tasks started not finished>\"],\n    \"blockers\": [\"<what prevents progress>\"],\n    \"next_actions\": [\"<concrete next steps>\"],\n    \"key_changes\": [\"<files/modules changed>\"]\n  }\n}\n\nFolder: .claude/memory/sessions/\nIndex format: - [SESSION_SUMMARY] summary -> .claude/memory/sessions/{slug}.json\n\n## RULES\n- Create .claude/memory/sessions/ if it doesn't exist\n- Never delete other category files\n- Keep index.md sorted by category then alphabetically; max 150 lines (remove oldest session_summary first if over)\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory DECISION capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and decision.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nWas a choice made between alternatives with stated rationale? There must be a clear 'chose X because Y' pattern -- not just discussion of options.\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to check for similar existing decision entries\n2. Generate descriptive kebab-case filename slug\n3. If updating existing decision: read file, merge new info, update updated_at\n4. If creating new: write complete JSON file\n5. Update index.md: add or update the one-line summary\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"decision\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"status\": \"<proposed|accepted|deprecated|superseded>\",\n    \"context\": \"<what prompted this decision>\",\n    \"decision\": \"<what was decided>\",\n    \"alternatives\": [{\"option\": \"<alt>\", \"rejected_reason\": \"<why not>\"}],\n    \"rationale\": [\"<reasons for choosing this, min 1>\"],\n    \"consequences\": [\"<known implications>\"]\n  }\n}\n\nFolder: .claude/memory/decisions/\nIndex format: - [DECISION] summary -> .claude/memory/decisions/{slug}.json\n\n## RULES\n- Create .claude/memory/decisions/ if it doesn't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category then alphabetically; max 150 lines\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory RUNBOOK capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and runbook.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nWas a non-trivial error diagnosed, fixed, AND verified in this session? All three must be present: (1) diagnosis of root cause, (2) fix applied, (3) verification that fix works.\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to check for similar existing runbook entries\n2. Generate descriptive kebab-case filename slug (e.g. fix-discourse-api-key-rotation)\n3. If updating existing runbook: read file, merge new info, update updated_at\n4. If creating new: write complete JSON file\n5. Update index.md: add or update the one-line summary\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"runbook\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"trigger\": \"<what symptom/error initiates this runbook>\",\n    \"symptoms\": [\"<observable signs>\"],\n    \"steps\": [\"<ordered fix steps, min 1>\"],\n    \"verification\": \"<how to confirm the fix worked>\",\n    \"root_cause\": \"<underlying cause>\",\n    \"environment\": \"<relevant env details>\"\n  }\n}\n\nFolder: .claude/memory/runbooks/\nIndex format: - [RUNBOOK] summary -> .claude/memory/runbooks/{slug}.json\n\n## RULES\n- Create .claude/memory/runbooks/ if it doesn't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category then alphabetically; max 150 lines\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory CONSTRAINT capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and constraint.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nWas a persistent limitation discovered from external factors (API limits, platform restrictions, legal requirements, infrastructure constraints)? Must be an enduring wall, not a temporary blocker or a bug to be fixed.\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to check for similar existing constraint entries\n2. Generate descriptive kebab-case filename slug (e.g. discourse-managed-pro-no-custom-plugins)\n3. If updating existing constraint: read file, merge new info, update updated_at\n4. If creating new: write complete JSON file\n5. Update index.md: add or update the one-line summary\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"constraint\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"kind\": \"<limitation|gap|policy|technical>\",\n    \"rule\": \"<the constraint stated clearly>\",\n    \"impact\": [\"<what this prevents or limits, min 1>\"],\n    \"workarounds\": [\"<known workarounds if any>\"],\n    \"severity\": \"<high|medium|low>\",\n    \"active\": true,\n    \"expires\": \"<condition or date when constraint may lift, or null>\"\n  }\n}\n\nFolder: .claude/memory/constraints/\nIndex format: - [CONSTRAINT] summary -> .claude/memory/constraints/{slug}.json\n\n## RULES\n- Create .claude/memory/constraints/ if it doesn't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category then alphabetically; max 150 lines\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory TECH_DEBT capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and tech_debt.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nWas work explicitly deferred with acknowledged cost or risk? There must be a clear 'deferring X because Y' pattern -- not just a TODO or wish list item.\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to check for similar existing tech_debt entries\n2. Generate descriptive kebab-case filename slug (e.g. csam-scanning-deferred-for-launch)\n3. If updating existing tech_debt: read file, merge new info, update updated_at\n4. If creating new: write complete JSON file\n5. Update index.md: add or update the one-line summary\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"tech_debt\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"status\": \"<open|in_progress|resolved|wont_fix>\",\n    \"priority\": \"<critical|high|medium|low>\",\n    \"description\": \"<what was deferred>\",\n    \"reason_deferred\": \"<why it was deferred>\",\n    \"impact\": [\"<consequences of not addressing>\"],\n    \"suggested_fix\": \"<recommended approach when addressed>\",\n    \"acceptance_criteria\": [\"<how to know it is resolved>\"]\n  }\n}\n\nFolder: .claude/memory/tech-debt/\nIndex format: - [TECH_DEBT] summary -> .claude/memory/tech-debt/{slug}.json\n\n## RULES\n- Create .claude/memory/tech-debt/ if it doesn't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category then alphabetically; max 150 lines\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      },
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory PREFERENCE capture hook.\n\n## FAST EXIT\nIf this turn was trivial (greeting, ack, simple Q&A, file reading without conclusions, or the last actions were memory file operations), output NOTHING and stop.\nIf .claude/memory/memory-config.json exists and preference.auto_capture is false, output NOTHING and stop.\n\n## TRIAGE\nWas a NEW convention established for future consistency? Must be a deliberate style/tool/workflow choice, not just following an existing convention or making a one-time exception.\nIf NO, output NOTHING and stop.\n\n## DISPATCH\n1. Read .claude/memory/index.md (if it exists) to check for similar existing preference entries\n2. Generate descriptive kebab-case filename slug (e.g. all-committed-content-must-be-english)\n3. If updating existing preference: read file, merge new info, update updated_at\n4. If creating new: write complete JSON file\n5. Update index.md: add or update the one-line summary\n\n## JSON FORMAT\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"preference\",\n  \"id\": \"<slug-matching-filename>\",\n  \"title\": \"<max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<min 1>\"],\n  \"related_files\": [],\n  \"confidence\": 0.0-1.0,\n  \"content\": {\n    \"topic\": \"<what area this preference covers>\",\n    \"value\": \"<the preferred approach>\",\n    \"reason\": \"<why this convention>\",\n    \"strength\": \"<strong|default|soft>\",\n    \"examples\": {\n      \"prefer\": [\"<do this>\"],\n      \"avoid\": [\"<not this>\"]\n    }\n  }\n}\n\nFolder: .claude/memory/preferences/\nIndex format: - [PREFERENCE] summary -> .claude/memory/preferences/{slug}.json\n\n## RULES\n- Create .claude/memory/preferences/ if it doesn't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category then alphabetically; max 150 lines\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory retrieval system. Your job is to find relevant memories for the user's request.\n\n## FAST EXIT\nIf .claude/memory/index.md does not exist, output nothing and stop.\n\n## RETRIEVE\n1. Read .claude/memory/index.md\n2. Compare each entry against the user's prompt\n3. Select entries that are semantically relevant to what the user is asking or working on\n4. If no entries are relevant, output nothing and stop\n\n## INJECT\nIf relevant entries exist (max 5), output ONLY this block:\n\nRELEVANT MEMORIES (from .claude/memory/):\n{list each relevant entry as: - [CATEGORY] summary -> filepath}\nRead the files above if you need detailed context for this task.\n\n## RULES\n- Maximum 5 entries per retrieval\n- Prefer decisions, constraints, and preferences over session summaries\n- Do NOT read the full JSON files -- only use index.md summaries for matching\n- Do NOT output anything if no memories are relevant\n- Be selective: only inject truly relevant memories, not tangentially related ones"
          }
        ]
      }
    ]
  }
}
