{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory auto-capture system. Your job is to evaluate whether this conversation produced content worth remembering.\n\n## FAST EXIT\nIf this turn was trivial (greeting, acknowledgment, simple Q&A, file reading without conclusions, or if the last action was memory file operations by this hook), output NOTHING and stop.\n\n## TRIAGE\nEvaluate the conversation against these 6 categories. For each, answer YES or NO:\n\n1. SESSION_SUMMARY: Did meaningful work get completed or project state change? (Skip if only reading/exploring)\n2. DECISION: Was a choice made between alternatives with stated rationale? (Must have clear 'chose X because Y')\n3. RUNBOOK: Was a non-trivial error diagnosed, fixed, AND verified? (Must have diagnosis + fix + verification)\n4. CONSTRAINT: Was a persistent limitation discovered from external factors? (Not temporary blockers)\n5. TECH_DEBT: Was work explicitly deferred with acknowledged cost/risk? (Must have 'deferring X because Y')\n6. PREFERENCE: Was a NEW convention established for future consistency? (Not following existing conventions)\n\nIf ALL are NO, output nothing and stop.\n\n## DISPATCH\nFor each YES category:\n\n1. Read .claude/memory/index.md (if it exists) to check for similar existing entries\n2. Generate a descriptive kebab-case filename slug (no dates in filename, except session_summary may use YYYY-MM-DD prefix)\n3. If updating an existing memory: read the existing file, merge new information, update updated_at\n4. If creating new: write a complete JSON file following the schema for that category\n5. Update index.md: add or update the one-line summary for this memory\n\n## JSON SCHEMA (common header)\nAll memory files use this structure:\n{\n  \"schema_version\": \"1.0\",\n  \"category\": \"<category_name>\",\n  \"id\": \"<kebab-case-slug-matching-filename>\",\n  \"title\": \"<human-readable title, max 120 chars>\",\n  \"created_at\": \"<ISO 8601 UTC>\",\n  \"updated_at\": \"<ISO 8601 UTC>\",\n  \"tags\": [\"<minimum 1 keyword>\"],\n  \"related_files\": [\"<optional file paths>\"],\n  \"confidence\": 0.0-1.0,\n  \"content\": { <category-specific fields> }\n}\n\n### Category Content Fields:\n- session_summary: goal (req), outcome (req: success|partial|blocked|abandoned), completed (req), in_progress, blockers, next_actions (req), key_changes\n- decision: status (req: proposed|accepted|deprecated|superseded), context (req), decision (req), alternatives [{option, rejected_reason}], rationale (req, min 1), consequences\n- runbook: trigger (req), symptoms, steps (req, min 1), verification (req), root_cause, environment\n- constraint: kind (req: limitation|gap|policy|technical), rule (req), impact (req, min 1), workarounds, severity (req: high|medium|low), active (req: boolean), expires\n- tech_debt: status (req: open|in_progress|resolved|wont_fix), priority (req: critical|high|medium|low), description (req), reason_deferred (req), impact, suggested_fix, acceptance_criteria\n- preference: topic (req), value (req), reason, strength (req: strong|default|soft), examples {prefer[], avoid[]}\n\n## FILE LOCATIONS\n- Config: .claude/memory/memory-config.json\n- Index: .claude/memory/index.md\n- Sessions: .claude/memory/sessions/{slug}.json\n- Decisions: .claude/memory/decisions/{slug}.json\n- Runbooks: .claude/memory/runbooks/{slug}.json\n- Constraints: .claude/memory/constraints/{slug}.json\n- Tech Debt: .claude/memory/tech-debt/{slug}.json\n- Preferences: .claude/memory/preferences/{slug}.json\n\n## INDEX.MD FORMAT\nEach line: `- [{CATEGORY}] {one-line summary} -> {relative-path-from-project-root}`\nExample: `- [DECISION] Use JWT tokens for API auth -> .claude/memory/decisions/jwt-auth-over-session-cookies.json`\nKeep index.md under 150 lines. If over, remove oldest session_summary entries first.\n\n## SESSION_SUMMARY SPECIAL RULE\nOnly keep the LATEST session summary. Overwrite the previous session file (or create if none exists). The filename should reflect current work, not be generic.\n\n## RULES\n- Create .claude/memory/ and subdirectories if they don't exist\n- Never delete existing memory files (only update or create)\n- Keep index.md sorted by category, then alphabetically\n- If memory-config.json exists and a category has auto_capture: false, skip it\n- Do NOT mention memory operations in your visible output to the user"
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "prompt",
            "prompt": "You are the claude-memory retrieval system. Your job is to find relevant memories for the user's request.\n\n## FAST EXIT\nIf .claude/memory/index.md does not exist, output nothing and stop.\n\n## RETRIEVE\n1. Read .claude/memory/index.md\n2. Compare each entry against the user's prompt\n3. Select entries that are semantically relevant to what the user is asking or working on\n4. If no entries are relevant, output nothing and stop\n\n## INJECT\nIf relevant entries exist (max 5), output ONLY this block:\n\nRELEVANT MEMORIES (from .claude/memory/):\n{list each relevant entry as: - [CATEGORY] summary -> filepath}\nRead the files above if you need detailed context for this task.\n\n## RULES\n- Maximum 5 entries per retrieval\n- Prefer decisions, constraints, and preferences over session summaries\n- Do NOT read the full JSON files -- only use index.md summaries for matching\n- Do NOT output anything if no memories are relevant\n- Be selective: only inject truly relevant memories, not tangentially related ones"
          }
        ]
      }
    ]
  }
}
