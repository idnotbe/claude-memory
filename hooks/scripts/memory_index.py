#!/usr/bin/env python3
"""
Memory index management utility for claude-memory plugin.

Rebuild, validate, or query the index.md file that serves as the
lightweight retrieval layer for stored memories.

Usage:
  python memory_index.py --rebuild --root .claude/memory
  python memory_index.py --validate --root .claude/memory
  python memory_index.py --query "authentication" --root .claude/memory

No external dependencies required (stdlib only).
"""

import argparse
import json
import os
import sys
from pathlib import Path

# Category folder mapping
CATEGORY_FOLDERS = {
    "session_summary": "sessions",
    "decision": "decisions",
    "runbook": "runbooks",
    "constraint": "constraints",
    "tech_debt": "tech-debt",
    "preference": "preferences",
}

CATEGORY_DISPLAY = {
    "session_summary": "SESSION_SUMMARY",
    "decision": "DECISION",
    "runbook": "RUNBOOK",
    "constraint": "CONSTRAINT",
    "tech_debt": "TECH_DEBT",
    "preference": "PREFERENCE",
}


def scan_memories(root: Path) -> list[dict]:
    """Scan all JSON files in category subfolders and extract metadata."""
    memories = []
    for category, folder in CATEGORY_FOLDERS.items():
        folder_path = root / folder
        if not folder_path.is_dir():
            continue
        for json_file in sorted(folder_path.glob("*.json")):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                title = data.get("title", json_file.stem)
                cat = data.get("category", category)
                display = CATEGORY_DISPLAY.get(cat, cat.upper())
                rel_path = json_file.relative_to(root.parent.parent)
                memories.append({
                    "category": cat,
                    "display": display,
                    "title": title,
                    "path": str(rel_path).replace("\\", "/"),
                    "file": json_file,
                })
            except (json.JSONDecodeError, KeyError) as e:
                print(f"WARNING: Could not parse {json_file}: {e}", file=sys.stderr)
    return memories


def rebuild_index(root: Path) -> None:
    """Scan all memory files and regenerate index.md."""
    memories = scan_memories(root)
    if not memories:
        print("No memory files found. Nothing to index.")
        return

    # Sort by category display name, then title
    memories.sort(key=lambda m: (m["display"], m["title"].lower()))

    lines = ["# Memory Index", "", "<!-- Auto-generated by memory_index.py. Do not edit manually. -->", ""]
    for m in memories:
        lines.append(f"- [{m['display']}] {m['title']} -> {m['path']}")
    lines.append("")

    index_path = root / "index.md"
    with open(index_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print(f"Rebuilt index.md with {len(memories)} entries at {index_path}")


def validate_index(root: Path) -> bool:
    """Compare index.md entries against actual files and report mismatches."""
    index_path = root / "index.md"
    if not index_path.exists():
        print("ERROR: index.md does not exist. Run --rebuild first.")
        return False

    # Parse index entries
    indexed_paths = set()
    with open(index_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line.startswith("- [") and " -> " in line:
                path_part = line.split(" -> ", 1)[1]
                indexed_paths.add(path_part)

    # Scan actual files
    actual_memories = scan_memories(root)
    actual_paths = {m["path"] for m in actual_memories}

    # Compare
    missing_from_index = actual_paths - indexed_paths
    stale_in_index = indexed_paths - actual_paths

    valid = True
    if missing_from_index:
        print("Files NOT in index.md:")
        for p in sorted(missing_from_index):
            print(f"  + {p}")
        valid = False

    if stale_in_index:
        print("Index entries with NO matching file:")
        for p in sorted(stale_in_index):
            print(f"  - {p}")
        valid = False

    if valid:
        print(f"Index is valid. {len(indexed_paths)} entries match {len(actual_paths)} files.")
    else:
        print(f"\nIndex has mismatches. Run --rebuild to fix.")

    return valid


def query_index(root: Path, query: str) -> None:
    """Search index entries by keyword."""
    index_path = root / "index.md"
    if not index_path.exists():
        print("ERROR: index.md does not exist. Run --rebuild first.")
        return

    query_lower = query.lower()
    matches = []
    with open(index_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line.startswith("- [") and query_lower in line.lower():
                matches.append(line)

    if matches:
        print(f"Found {len(matches)} match(es) for '{query}':")
        for m in matches:
            print(f"  {m}")
    else:
        print(f"No matches found for '{query}'.")


def main():
    parser = argparse.ArgumentParser(
        description="Memory index management utility for claude-memory plugin."
    )
    parser.add_argument(
        "--root",
        type=str,
        default=".claude/memory",
        help="Root directory of memory storage (default: .claude/memory)",
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "--rebuild",
        action="store_true",
        help="Scan all memory files and regenerate index.md",
    )
    group.add_argument(
        "--validate",
        action="store_true",
        help="Check index.md against actual files",
    )
    group.add_argument(
        "--query",
        type=str,
        metavar="KEYWORD",
        help="Search index entries by keyword",
    )

    args = parser.parse_args()
    root = Path(args.root)

    if not root.is_dir():
        print(f"ERROR: Memory root '{root}' is not a directory.", file=sys.stderr)
        sys.exit(1)

    if args.rebuild:
        rebuild_index(root)
    elif args.validate:
        ok = validate_index(root)
        sys.exit(0 if ok else 1)
    elif args.query:
        query_index(root, args.query)


if __name__ == "__main__":
    main()
